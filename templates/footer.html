<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mic</title>
</head>
<body>
    <!-- Include the draggable footer -->
    <div id="footer-container"></div>

    <script>
        // Load footer template via AJAX ( with direct insertion)
        function loadFooter() {
            const footerHTML = `
                <!-- templates/footer.html -->
                <style>
                    #mic-button {
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        z-index: 9999;
                        background: linear-gradient(135deg, rgb(92, 37, 193), rgb(147, 51, 234));
                        border: none;
                        border-radius: 50%;
                        padding: 18px;
                        color: white;
                        font-size: 24px;
                        cursor: grab;
                        box-shadow: 0 6px 20px rgba(92, 37, 193, 0.4);
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        user-select: none;
                        width: 60px;
                        height: 60px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        touch-action: none;
                        -webkit-touch-callout: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    }

                    #mic-button:hover {
                        transform: scale(1.1);
                        box-shadow: 0 8px 25px rgba(92, 37, 193, 0.6);
                        background: linear-gradient(135deg, rgb(107, 52, 208), rgb(162, 66, 249));
                    }

                    #mic-button:active {
                        cursor: grabbing;
                        transform: scale(0.95);
                    }

                    #mic-button.recording {
                        background: linear-gradient(135deg, #ef4444, #dc2626);
                        animation: pulse 1s infinite;
                    }

                    #mic-button.dragging {
                        cursor: grabbing;
                        transform: scale(1.1);
                        transition: none;
                        opacity: 0.8;
                    }

                    #mic-button.disabled {
                        background: #6b7280;
                        cursor: not-allowed;
                        opacity: 0.6;
                    }

                    @keyframes pulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.05); }
                    }

                    .mic-tooltip {
                        position: absolute;
                        bottom: 70px;
                        right: 0;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 12px;
                        white-space: nowrap;
                        opacity: 0;
                        transform: translateY(10px);
                        transition: all 0.3s ease;
                        pointer-events: none;
                        z-index: 10000;
                    }

                    #mic-button:hover .mic-tooltip {
                        opacity: 1;
                        transform: translateY(0);
                    }

                    .error-tooltip {
                        background: rgba(239, 68, 68, 0.9) !important;
                    }

                    /* Mobile-specific styles */
                    @media (max-width: 768px) {
                        #mic-button {
                            width: 56px;
                            height: 56px;
                            font-size: 20px;
                            padding: 16px;
                        }
                        
                        .mic-tooltip {
                            font-size: 10px;
                            padding: 6px 8px;
                        }
                    }
                </style>

                <button id="mic-button" title="Voice Assistant - Drag me around!">
                    üé§
                    <div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>
                </button>
            `;
            
            document.getElementById('footer-container').innerHTML = footerHTML;
            initializeVoiceAssistant();
        }

        function initializeVoiceAssistant() {
            const micBtn = document.getElementById('mic-button');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let isRecording = false;
            let clickTimeout = null;
            let dragStartTime = 0;
            let dragThreshold = 5; // pixels
            let startPosition = { x: 0, y: 0 };
            let hasMoved = false;

            // Check if MediaRecorder is supported
            if (!window.MediaRecorder) {
                micBtn.classList.add('disabled');
                micBtn.querySelector('.mic-tooltip').textContent = 'Voice recording not supported';
                micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                return;
            }

            // Get the best supported audio format
            function getSupportedAudioFormat() {
                const formats = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4;codecs=aac',
                    'audio/mp4',
                    'audio/ogg;codecs=opus',
                    'audio/ogg'
                ];

                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        return format;
                    }
                }
                
                // Fallback - try without specifying format
                return '';
            }

            // Reset drag state
            function resetDragState() {
                isDragging = false;
                hasMoved = false;
                micBtn.classList.remove('dragging');
                micBtn.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                
                // Clear any pending timeouts
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                }
            }

            // Get position from event (mouse or touch)
            function getEventPosition(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }

            // Update button position
            function updateButtonPosition(x, y) {
                // Keep button within viewport bounds
                const maxX = window.innerWidth - micBtn.offsetWidth;
                const maxY = window.innerHeight - micBtn.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(x, maxX));
                const constrainedY = Math.max(0, Math.min(y, maxY));
                
                micBtn.style.left = constrainedX + 'px';
                micBtn.style.top = constrainedY + 'px';
                micBtn.style.right = 'auto';
                micBtn.style.bottom = 'auto';
                micBtn.style.transition = 'none';
            }

            // Start drag (unified for mouse and touch)
            function startDrag(e) {
                if (isRecording || micBtn.classList.contains('disabled')) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const position = getEventPosition(e);
                dragStartTime = Date.now();
                startPosition = { x: position.x, y: position.y };
                hasMoved = false;
                
                const rect = micBtn.getBoundingClientRect();
                dragOffset.x = position.x - rect.left;
                dragOffset.y = position.y - rect.top;
                
                // Clear any pending click timeout
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                }
                
                // Set up drag state after a small delay to distinguish from clicks
                setTimeout(() => {
                    if (dragStartTime > 0) { // Only if we haven't already ended
                        isDragging = true;
                        micBtn.classList.add('dragging');
                    }
                }, 100);
            }

            // Handle drag movement (unified for mouse and touch)
            function handleDragMove(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const position = getEventPosition(e);
                const deltaX = Math.abs(position.x - startPosition.x);
                const deltaY = Math.abs(position.y - startPosition.y);
                
                // Check if we've moved enough to consider this a real drag
                if (deltaX > dragThreshold || deltaY > dragThreshold) {
                    hasMoved = true;
                }
                
                const x = position.x - dragOffset.x;
                const y = position.y - dragOffset.y;
                
                updateButtonPosition(x, y);
            }

            // End drag (unified for mouse and touch)
            function endDrag(e) {
                const wasDragging = isDragging;
                const didMove = hasMoved;
                const dragDuration = Date.now() - dragStartTime;
                
                dragStartTime = 0;
                resetDragState();
                
                // If we were dragging or moved significantly, prevent click
                if (wasDragging && didMove) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                
                // If it was a very short interaction without movement, treat as click
                if (!didMove && dragDuration < 200) {
                    // Allow click to proceed naturally
                    return;
                }
                
                // Prevent click for anything else
                e.preventDefault();
                e.stopPropagation();
            }

            // Mouse events
            micBtn.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', endDrag);

            // Touch events with proper passive handling
            micBtn.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', endDrag, { passive: false });

            // Click handler for recording
            micBtn.addEventListener('click', async (e) => {
                // Prevent if disabled or recording
                if (micBtn.classList.contains('disabled') || isRecording) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                
                // Prevent if we just finished dragging
                if (hasMoved || isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                // Add small delay to ensure drag state is settled
                clickTimeout = setTimeout(async () => {
                    if (!isDragging && !hasMoved) {
                        await handleRecording();
                    }
                }, 50);
            });

            async function handleRecording() {
                try {
                    isRecording = true;
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = '‚èπÔ∏è<div class="mic-tooltip">Recording... (3s)</div>';
                    
                    // Request microphone access with better error handling
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100
                        }
                    });
                    
                    // Get the best supported format
                    const mimeType = getSupportedAudioFormat();
                    console.log('Using audio format:', mimeType);
                    
                    // Create MediaRecorder with proper options
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType || undefined,
                        audioBitsPerSecond: 128000
                    });
                    
                    let audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        // Clean up stream
                        stream.getTracks().forEach(track => track.stop());
                        
                        isRecording = false;
                        micBtn.classList.remove('recording');
                        micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                        
                        if (audioChunks.length === 0) {
                            throw new Error('No audio data recorded');
                        }
                        
                        // Create blob with the recorded format
                        const actualMimeType = mediaRecorder.mimeType || mimeType || 'audio/webm';
                        const blob = new Blob(audioChunks, { type: actualMimeType });
                        
                        // Determine file extension based on mime type
                        let fileExtension = 'webm';
                        if (actualMimeType.includes('mp4')) {
                            fileExtension = 'mp4';
                        } else if (actualMimeType.includes('ogg')) {
                            fileExtension = 'ogg';
                        }

                        const formData = new FormData();
                        formData.append('audio', blob, `command.${fileExtension}`);
                        formData.append('mimeType', actualMimeType);

                        try {
                            // Show processing state
                            micBtn.innerHTML = '‚è≥<div class="mic-tooltip">Processing...</div>';
                            
                            const response = await fetch('/voice-command', {
                                method: 'POST',
                                body: formData,
                                // Add headers for better compatibility
                                headers: {
                                    'Accept': 'application/json',
                                }
                            });

                            if (!response.ok) {
                                throw new Error(`Server error: ${response.status}`);
                            }

                            const result = await response.json();
                            
                            // Reset button
                            micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                            
                            if (result.redirect_url) {
                                const utterance = new SpeechSynthesisUtterance(result.speech_response);
                                speechSynthesis.speak(utterance);
                                utterance.onend = () => {
                                    window.location.href = result.redirect_url;
                                };
                            } else if (result.speech_response) {
                                speechSynthesis.speak(new SpeechSynthesisUtterance(result.speech_response));
                            } else {
                                speechSynthesis.speak(new SpeechSynthesisUtterance("Sorry, I didn't catch that."));
                            }
                        } catch (fetchError) {
                            console.error('Voice command processing error:', fetchError);
                            micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                            speechSynthesis.speak(new SpeechSynthesisUtterance("Sorry, there was an error processing your command."));
                        }
                    };

                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        stream.getTracks().forEach(track => track.stop());
                        isRecording = false;
                        micBtn.classList.remove('recording');
                        micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                    };

                    mediaRecorder.start();
                    
                    // Auto-stop after 3 seconds
                    setTimeout(() => {
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                    }, 3000);
                    
                } catch (error) {
                    console.error('Voice Assistant Error:', error);
                    isRecording = false;
                    micBtn.classList.remove('recording');
                    micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                    
                    let errorMessage = "Microphone error occurred.";
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage = "Please allow microphone access and try again.";
                        micBtn.querySelector('.mic-tooltip').textContent = 'Microphone access denied';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = "No microphone found.";
                        micBtn.querySelector('.mic-tooltip').textContent = 'No microphone found';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage = "Audio recording not supported in this browser.";
                        micBtn.classList.add('disabled');
                        micBtn.querySelector('.mic-tooltip').textContent = 'Recording not supported';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    }
                    
                    speechSynthesis.speak(new SpeechSynthesisUtterance(errorMessage));
                }
            }

            // Prevent context menu on right-click
            micBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                const rect = micBtn.getBoundingClientRect();
                const maxX = window.innerWidth - micBtn.offsetWidth;
                const maxY = window.innerHeight - micBtn.offsetHeight;
                
                if (rect.left > maxX) {
                    micBtn.style.left = maxX + 'px';
                }
                if (rect.top > maxY) {
                    micBtn.style.top = maxY + 'px';
                }
            });

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                resetDragState();
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                }
            });

            // Handle visibility change (tab switching)
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    resetDragState();
                }
            });
        }

        // Load the footer when page loads
        document.addEventListener('DOMContentLoaded', loadFooter);

        // Alternative: Load footer via AJAX from external file
        function loadFooterViaAJAX() {
            fetch('/templates/footer.html')
                .then(response => response.text())
                .then(html => {
                    document.getElementById('footer-container').innerHTML = html;
                    initializeVoiceAssistant();
                })
                .catch(error => {
                    console.error('Error loading footer:', error);
                    // Fallback to inline version
                    loadFooter();
                });
        }
    </script>
</body>
</html>