<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mic</title>
</head>
<body>
    <!-- Include the draggable footer -->
    <div id="footer-container"></div>

    <script>
        // Load footer template via AJAX (simulated with direct insertion for demo)
        function loadFooter() {
            const footerHTML = `
                <!-- templates/footer.html -->
                <style>
                    #mic-button {
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        z-index: 9999;
                        background: linear-gradient(135deg, rgb(92, 37, 193), rgb(147, 51, 234));
                        border: none;
                        border-radius: 50%;
                        padding: 18px;
                        color: white;
                        font-size: 24px;
                        cursor: grab;
                        box-shadow: 0 6px 20px rgba(92, 37, 193, 0.4);
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        user-select: none;
                        width: 60px;
                        height: 60px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    #mic-button:hover {
                        transform: scale(1.1);
                        box-shadow: 0 8px 25px rgba(92, 37, 193, 0.6);
                        background: linear-gradient(135deg, rgb(107, 52, 208), rgb(162, 66, 249));
                    }

                    #mic-button:active {
                        cursor: grabbing;
                        transform: scale(0.95);
                    }

                    #mic-button.recording {
                        background: linear-gradient(135deg, #ef4444, #dc2626);
                        animation: pulse 1s infinite;
                    }

                    #mic-button.dragging {
                        cursor: grabbing;
                        transform: scale(1.1);
                        transition: none;
                    }

                    #mic-button.disabled {
                        background: #6b7280;
                        cursor: not-allowed;
                        opacity: 0.6;
                    }

                    @keyframes pulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.05); }
                    }

                    .mic-tooltip {
                        position: absolute;
                        bottom: 70px;
                        right: 0;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 12px;
                        white-space: nowrap;
                        opacity: 0;
                        transform: translateY(10px);
                        transition: all 0.3s ease;
                        pointer-events: none;
                        z-index: 10000;
                    }

                    #mic-button:hover .mic-tooltip {
                        opacity: 1;
                        transform: translateY(0);
                    }

                    .error-tooltip {
                        background: rgba(239, 68, 68, 0.9) !important;
                    }
                </style>

                <button id="mic-button" title="Voice Assistant - Drag me around!">
                    üé§
                    <div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>
                </button>
            `;
            
            document.getElementById('footer-container').innerHTML = footerHTML;
            initializeVoiceAssistant();
        }

        function initializeVoiceAssistant() {
            const micBtn = document.getElementById('mic-button');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let isRecording = false;
            let clickTimeout = null;

            // Check if MediaRecorder is supported
            if (!window.MediaRecorder) {
                micBtn.classList.add('disabled');
                micBtn.querySelector('.mic-tooltip').textContent = 'Voice recording not supported';
                micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                return;
            }

            // Get the best supported audio format
            function getSupportedAudioFormat() {
                const formats = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4;codecs=aac',
                    'audio/mp4',
                    'audio/ogg;codecs=opus',
                    'audio/ogg'
                ];

                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        return format;
                    }
                }
                
                // Fallback - try without specifying format
                return '';
            }

            // Dragging functionality
            micBtn.addEventListener('mousedown', (e) => {
                if (isRecording || micBtn.classList.contains('disabled')) return;
                
                // Clear any pending click timeout
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                }
                
                isDragging = true;
                micBtn.classList.add('dragging');
                
                const rect = micBtn.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                // Keep button within viewport bounds
                const maxX = window.innerWidth - micBtn.offsetWidth;
                const maxY = window.innerHeight - micBtn.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(x, maxX));
                const constrainedY = Math.max(0, Math.min(y, maxY));
                
                micBtn.style.left = constrainedX + 'px';
                micBtn.style.top = constrainedY + 'px';
                micBtn.style.right = 'auto';
                micBtn.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    micBtn.classList.remove('dragging');
                    
                    // Prevent click event after drag
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Touch support for mobile
            micBtn.addEventListener('touchstart', (e) => {
                if (isRecording || micBtn.classList.contains('disabled')) return;
                
                isDragging = true;
                micBtn.classList.add('dragging');
                
                const touch = e.touches[0];
                const rect = micBtn.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
                
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const x = touch.clientX - dragOffset.x;
                const y = touch.clientY - dragOffset.y;
                
                const maxX = window.innerWidth - micBtn.offsetWidth;
                const maxY = window.innerHeight - micBtn.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(x, maxX));
                const constrainedY = Math.max(0, Math.min(y, maxY));
                
                micBtn.style.left = constrainedX + 'px';
                micBtn.style.top = constrainedY + 'px';
                micBtn.style.right = 'auto';
                micBtn.style.bottom = 'auto';
                
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    micBtn.classList.remove('dragging');
                }
            });

            // Voice recording functionality (enhanced with proper format detection)
            micBtn.addEventListener('click', async (e) => {
                // Prevent click if we just finished dragging
                if (isDragging) return;
                
                // Prevent double-clicks
                if (isRecording || micBtn.classList.contains('disabled')) return;
                
                // Add small delay to distinguish between drag and click
                clickTimeout = setTimeout(async () => {
                    await handleRecording();
                }, 100);
            });

            async function handleRecording() {
                try {
                    isRecording = true;
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = '‚èπÔ∏è<div class="mic-tooltip">Recording... (3s)</div>';
                    
                    // Request microphone access with better error handling
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100
                        }
                    });
                    
                    // Get the best supported format
                    const mimeType = getSupportedAudioFormat();
                    console.log('Using audio format:', mimeType);
                    
                    // Create MediaRecorder with proper options
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType || undefined,
                        audioBitsPerSecond: 128000
                    });
                    
                    let audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        // Clean up stream
                        stream.getTracks().forEach(track => track.stop());
                        
                        isRecording = false;
                        micBtn.classList.remove('recording');
                        micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                        
                        if (audioChunks.length === 0) {
                            throw new Error('No audio data recorded');
                        }
                        
                        // Create blob with the recorded format
                        const actualMimeType = mediaRecorder.mimeType || mimeType || 'audio/webm';
                        const blob = new Blob(audioChunks, { type: actualMimeType });
                        
                        // Determine file extension based on mime type
                        let fileExtension = 'webm';
                        if (actualMimeType.includes('mp4')) {
                            fileExtension = 'mp4';
                        } else if (actualMimeType.includes('ogg')) {
                            fileExtension = 'ogg';
                        }

                        const formData = new FormData();
                        formData.append('audio', blob, `command.${fileExtension}`);
                        formData.append('mimeType', actualMimeType);

                        try {
                            // Show processing state
                            micBtn.innerHTML = '‚è≥<div class="mic-tooltip">Processing...</div>';
                            
                            const response = await fetch('/voice-command', {
                                method: 'POST',
                                body: formData,
                                // Add headers for better compatibility
                                headers: {
                                    'Accept': 'application/json',
                                }
                            });

                            if (!response.ok) {
                                throw new Error(`Server error: ${response.status}`);
                            }

                            const result = await response.json();
                            
                            // Reset button
                            micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                            
                            if (result.redirect_url) {
                                const utterance = new SpeechSynthesisUtterance(result.speech_response);
                                speechSynthesis.speak(utterance);
                                utterance.onend = () => {
                                    window.location.href = result.redirect_url;
                                };
                            } else if (result.speech_response) {
                                speechSynthesis.speak(new SpeechSynthesisUtterance(result.speech_response));
                            } else {
                                speechSynthesis.speak(new SpeechSynthesisUtterance("Sorry, I didn't catch that."));
                            }
                        } catch (fetchError) {
                            console.error('Voice command processing error:', fetchError);
                            micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                            speechSynthesis.speak(new SpeechSynthesisUtterance("Sorry, there was an error processing your command."));
                        }
                    };

                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        stream.getTracks().forEach(track => track.stop());
                        isRecording = false;
                        micBtn.classList.remove('recording');
                        micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                    };

                    mediaRecorder.start();
                    
                    // Auto-stop after 3 seconds
                    setTimeout(() => {
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                    }, 3000);
                    
                } catch (error) {
                    console.error('Voice Assistant Error:', error);
                    isRecording = false;
                    micBtn.classList.remove('recording');
                    micBtn.innerHTML = 'üé§<div class="mic-tooltip">Click to record ‚Ä¢ Drag to move</div>';
                    
                    let errorMessage = "Microphone error occurred.";
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage = "Please allow microphone access and try again.";
                        micBtn.querySelector('.mic-tooltip').textContent = 'Microphone access denied';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = "No microphone found.";
                        micBtn.querySelector('.mic-tooltip').textContent = 'No microphone found';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage = "Audio recording not supported in this browser.";
                        micBtn.classList.add('disabled');
                        micBtn.querySelector('.mic-tooltip').textContent = 'Recording not supported';
                        micBtn.querySelector('.mic-tooltip').classList.add('error-tooltip');
                    }
                    
                    speechSynthesis.speak(new SpeechSynthesisUtterance(errorMessage));
                }
            }

            // Prevent context menu on right-click
            micBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                const rect = micBtn.getBoundingClientRect();
                const maxX = window.innerWidth - micBtn.offsetWidth;
                const maxY = window.innerHeight - micBtn.offsetHeight;
                
                if (rect.left > maxX) {
                    micBtn.style.left = maxX + 'px';
                }
                if (rect.top > maxY) {
                    micBtn.style.top = maxY + 'px';
                }
            });
        }

        // Load the footer when page loads
        document.addEventListener('DOMContentLoaded', loadFooter);

        // Alternative: Load footer via AJAX from external file
        function loadFooterViaAJAX() {
            fetch('/templates/footer.html')
                .then(response => response.text())
                .then(html => {
                    document.getElementById('footer-container').innerHTML = html;
                    initializeVoiceAssistant();
                })
                .catch(error => {
                    console.error('Error loading footer:', error);
                    // Fallback to inline version
                    loadFooter();
                });
        }
    </script>
</body>
</html>